--- /dev/null	2008-05-03 07:58:55.024032298 -0700
+++ libmpcodecs/vd_dshowserver.c	2008-05-13 21:12:10.000000000 -0700
@@ -0,0 +1,198 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <semaphore.h>
+#include <sys/mman.h>
+#include <pthread.h>
+
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <time.h>
+
+#include "config.h"
+
+#include "mp_msg.h"
+#include "help_mp.h"
+
+#include "vd_internal.h"
+
+struct vd_struct {
+  union {
+    uint32_t ret;
+    uint32_t cmd;
+  };
+  uint32_t buflen;
+} __attribute__((__packed__));
+
+static int sem_twait(sem_t *sem, int t) {
+    struct timespec ts;
+    clock_gettime(CLOCK_REALTIME, &ts);
+    ts.tv_sec += t;
+    return(sem_timedwait(sem, &ts));
+}
+
+static struct timespec total_ts;
+static vd_info_t info = {
+	"DirectShowServer video codecs",
+	"dshowserver",
+	"Alan Nisota",
+	"based on dshow",
+	"win32 codecs"
+};
+
+LIBVD_EXTERN(dshowserver)
+typedef struct {
+    int fd;
+    void *mem;
+    char *data;
+    char *picture;
+    int picsize;
+    int pagesize;
+    sem_t *sem_rd;
+    sem_t *sem_wr;
+    struct vd_struct *vd;
+} ds_mpi_t;
+static ds_mpi_t *ds_mpi;
+
+// to set/get/query special features/parameters
+static int control(sh_video_t *sh __attribute((unused)),int cmd,void* arg __attribute((unused)),...){
+    switch(cmd){
+    case VDCTRL_QUERY_MAX_PP_LEVEL:
+	return 4;
+    case VDCTRL_QUERY_UNSEEN_FRAMES:
+	return 12;
+
+    }
+    return CONTROL_UNKNOWN;
+}
+
+// init driver
+static int init(sh_video_t *sh){
+    int ret;
+    char cmd[255], shm[80], sem1[80], sem2[80];
+    uint32_t out_fmt;
+    int bpp, w, h;
+    int extra = 0;
+    int numpages = 10;
+    int memsize;
+    total_ts.tv_sec = 0; total_ts.tv_nsec = 0;
+    out_fmt = sh->codec->outfmt[sh->outfmtidx];
+    switch(out_fmt){
+      case IMGFMT_YUY2:
+      case IMGFMT_UYVY:
+	bpp = 16; break;
+      case IMGFMT_YV12:
+      case IMGFMT_I420:
+      case IMGFMT_IYUV:
+	bpp = 12; break;
+      case IMGFMT_YVU9:
+        bpp = 9; break;
+      default:
+        bpp = 24; break;
+    }
+    w = sh->disp_w; h = sh->disp_h;
+    snprintf(cmd, 255, "dshowserver -c %s -s %dx%d "
+             "-g %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x "
+             "-f 0x%08x -b %d -o 0x%08x -p %d -i %x -n %d %s&",
+             sh->codec->dll, w, h,
+             (unsigned int)sh->codec->guid.f1, sh->codec->guid.f2, sh->codec->guid.f3,
+             sh->codec->guid.f4[0], sh->codec->guid.f4[1], sh->codec->guid.f4[2], sh->codec->guid.f4[3],
+             sh->codec->guid.f4[4], sh->codec->guid.f4[5], sh->codec->guid.f4[6], sh->codec->guid.f4[7],
+             (unsigned int)sh->format, bpp, out_fmt, getpid(), *(int *)pthread_self(), numpages, "");
+    snprintf(shm, 80, "/dshow_shm.%x", *(int *)pthread_self());
+    snprintf(sem1, 80, "/dshow_sem1.%x", *(int *)pthread_self());
+    snprintf(sem2, 80, "/dshow_sem2.%x", *(int *)pthread_self());
+    ds_mpi = (ds_mpi_t *) malloc(sizeof(ds_mpi_t));
+    ds_mpi->fd = shm_open(shm, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
+    ds_mpi->picsize =  w * h * bpp / 8;
+    ds_mpi->pagesize = ds_mpi->picsize + 1024;
+    memsize = sizeof(struct vd_struct) + w * h + ds_mpi->picsize + extra + ds_mpi->pagesize * numpages;
+    ftruncate(ds_mpi->fd, memsize);
+    ds_mpi->mem = mmap(NULL, memsize, PROT_READ | PROT_WRITE, MAP_SHARED, ds_mpi->fd, 0);
+    if(ds_mpi->mem == MAP_FAILED) {
+      perror("mmap");
+      return 0;
+    }
+    if (extra)
+      memset((char *)ds_mpi->mem + (memsize - extra), 0, extra);
+    ds_mpi->vd = (struct vd_struct *)ds_mpi->mem;
+    ds_mpi->data = ((char *)ds_mpi->mem) + sizeof(struct vd_struct);
+    ds_mpi->picture = ds_mpi->data + w * h;
+    //Create read/write semaphores in locked state
+    ds_mpi->sem_wr = sem_open(sem1, O_CREAT, 0644, 0);
+    ds_mpi->sem_rd = sem_open(sem2, O_CREAT, 0644, 0);
+    system(cmd);
+    ret = sem_twait(ds_mpi->sem_rd, 10);
+    shm_unlink(shm);
+    sem_unlink(sem1);
+    sem_unlink(sem2);
+    if(ret != 0) {
+      printf("DirectShow filter failed");
+      return 0;
+    } else {
+      if(!mpcodecs_config_vo(sh,w,h,IMGFMT_YUY2)) return 0;
+      printf("Found DirectShow filter");
+      return 1;
+    }
+}
+
+// uninit driver
+static void uninit(sh_video_t *sh){
+    printf("Runtime: %d.%d\n", total_ts.tv_sec, total_ts.tv_nsec);
+    if(ds_mpi) {
+      printf("Destroying filter");
+      ds_mpi->vd->cmd = 1; //'1' is cmd for terminating
+      sem_post(ds_mpi->sem_wr);
+      close(ds_mpi->fd);
+      sem_close(ds_mpi->sem_wr);
+      sem_close(ds_mpi->sem_rd);
+      free(ds_mpi);
+      ds_mpi = NULL;
+    }
+}
+
+//mp_image_t* mpcodecs_get_image(sh_video_t *sh, int mp_imgtype, int mp_imgflag, int w, int h);
+
+// decode a frame
+static mp_image_t* decode(sh_video_t *sh,void* data,int len,int flags){
+   struct timespec ts1, ts2;
+   mp_image_t* mpi = NULL;
+   int ret;
+   if(len<=0) return NULL; // skipped frame
+    
+   if(flags&3) {
+      // framedrop:
+      return NULL;
+   }
+   clock_gettime(CLOCK_REALTIME, &ts1);
+   ds_mpi->vd->cmd = 2; //'1' is cmd for decoding
+   memcpy(ds_mpi->data, data, len);
+   ds_mpi->vd->buflen = len;
+   sem_post(ds_mpi->sem_wr);
+   ret = sem_twait(ds_mpi->sem_rd, 10);
+   if(ret == 0 && ds_mpi->vd->ret && ! (ds_mpi->vd->ret & (1<<31))) {
+     mpi=mpcodecs_get_image(sh, MP_IMGTYPE_TEMP, 0 /*MP_IMGFLAG_ACCEPT_STRIDE*/, 
+                            sh->disp_w, sh->disp_h);
+     if(ds_mpi->vd->ret & 0x02) {
+       unsigned char page = ds_mpi->vd->ret >> 8;
+       memcpy(mpi->planes[0], ds_mpi->picture + ds_mpi->picsize + page * ds_mpi->pagesize, ds_mpi->picsize);
+     } else {
+       memcpy(mpi->planes[0], ds_mpi->picture, ds_mpi->picsize);
+     }
+   }
+   clock_gettime(CLOCK_REALTIME, &ts2);
+   if(ts2.tv_nsec < ts1.tv_nsec) {
+     total_ts.tv_sec--;
+     total_ts.tv_nsec += 1E9 - (ts1.tv_nsec - ts2.tv_nsec);
+   } else {
+     total_ts.tv_nsec += (ts2.tv_nsec - ts1.tv_nsec);
+   }
+   if(total_ts.tv_nsec > 1E9) {
+     total_ts.tv_sec++;
+     total_ts.tv_nsec-=1E9;
+   }
+   total_ts.tv_sec += (ts2.tv_sec - ts1.tv_sec);
+   return mpi;
+}
Index: Makefile
===================================================================
--- Makefile	(revision 26763)
+++ Makefile	(working copy)
@@ -5,6 +5,7 @@
 #			* DVD support
 
 include config.mak
+EXTRALIBS += -lrt
 
 
 ###### variable declarations #######
@@ -460,6 +461,7 @@
                                         libmpcodecs/ad_twin.c \
                                         libmpcodecs/vd_dmo.c \
                                         libmpcodecs/vd_dshow.c \
+                                        libmpcodecs/vd_dshowserver.c \
                                         libmpcodecs/vd_vfw.c \
                                         libmpcodecs/vd_vfwex.c \
                                         libmpdemux/demux_avs.c \
Index: libmpcodecs/vd.c
===================================================================
--- libmpcodecs/vd.c    (revision 26763)
+++ libmpcodecs/vd.c    (working copy)
@@ -29,6 +29,7 @@
 extern vd_functions_t mpcodecs_vd_ffmpeg;
 extern vd_functions_t mpcodecs_vd_theora;
 extern vd_functions_t mpcodecs_vd_dshow;
+extern vd_functions_t mpcodecs_vd_dshowserver;
 extern vd_functions_t mpcodecs_vd_dmo;
 extern vd_functions_t mpcodecs_vd_vfw;
 extern vd_functions_t mpcodecs_vd_vfwex;
@@ -63,6 +64,7 @@
 #endif
 #ifdef USE_WIN32DLL
         &mpcodecs_vd_dshow,
+        &mpcodecs_vd_dshowserver,
         &mpcodecs_vd_dmo,
         &mpcodecs_vd_vfw,
         &mpcodecs_vd_vfwex,

